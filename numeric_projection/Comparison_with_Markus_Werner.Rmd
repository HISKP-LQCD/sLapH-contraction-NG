---
title: "Comparison_with_Markus_Werner.Rmd"
author: "Martin Ueding"
date: "16 August 2019"
output: pdf_document
---

In this notebook we compare the data from the new projection code with the results that Markus Werner has generated with his code.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(ggplot2)
library(paramvalf)
library(tibble)

debug_mode = TRUE
```

```{r}
total_momentum_ref <- function (total_momentum_sq) {
  if (total_momentum_sq == 0)
    c(0, 0, 0)
  else if (total_momentum_sq == 1)
    c(0, 0, 1)
  else if (total_momentum_sq == 2)
    c(1, 1, 0)
  else if (total_momentum_sq == 3)
    c(1, 1, 1)
  else if (total_momentum_sq == 1)
    c(0, 0, 2)
}

momentum_to_string <- function (momentum) {
  paste0(sprintf("%d", momentum), collapse = '')
}

total_momentum_str_to_vec <- function (total_momentum_str) {
  parts <- stringr::str_match(total_momentum_str, '(-?\\d)(-?\\d)(-?\\d)')
  sapply(parts[1, 2:4], as.integer)
}
```

This comparison will use the paramvalf framework within a single notebook. Users of the framework might miss the `pv_load` and `pv_save` calls but we are just using it as a library and not as a fully fleged framework here.

# Reading actual data

We will do all the comparisons to the total momenta and irreps that we have projected. For this we just parse all the files for a selected configuration and build a parameter table out of them.

```{r}
split_filename <- function (path) {
  filename <- basename(path)
  parts <- stringr::str_match(filename, 'resolved_(.*)_(.*)_(.*)\\.js')
  parts[1, 2:4]
}

workdir <- '~/Lattice/NG2'

all_projected_paths <- Sys.glob(paste0(workdir, '/projected/resolved_*_*_2552.js'))

parts <- do.call(rbind, lapply(all_projected_paths, split_filename))
colnames(parts) <- c('total_momentum_str', 'irrep', 'config_number')
df <- as_tibble(parts)
df$path <- all_projected_paths
df$config_number <- as.integer(df$config_number)

irreps <- df_to_paramval(df, c('total_momentum_str', 'irrep', 'config_number'))
```

```{r}
.func <- function (param, value) {
  total_momentum_vec <- total_momentum_str_to_vec(param$total_momentum_str)
  total_momentum_sq <- sum(total_momentum_vec^2)
  
  list(
    total_momentum_vec = total_momentum_vec,
    total_momentum_sq = total_momentum_sq)
}

total_momentum <- pv_call(.func, irreps)
```

For each irrep we need to figure out which relative momenta $q$ we actually have in our data. We read in the actual data and convert the parametrization to the one that Markus has used.

```{r}
.func <- function (param, value) {
  data <- jsonlite::read_json(value$path)
  q_avail_actual <- names(data[[param$total_momentum_str]][[param$irrep]][['1']][['1']])
  
  list(actual_avail = q_avail_actual)
}

actual_avail <- pv_call(.func, irreps, total_momentum)
```

# Reading target data

```{r}
parse_markus_gevp_indices <- function (line) {
  pattern <- 'p: (\\d+), q: \\(([\\d.]+), ([\\d.]+), ([\\d.]+)\\), g: \\\\gamma_\\{5\\}, \\\\gamma_\\{5\\}'
  match <- stringr::str_match(line, pattern)
  total_momentum_sq <- as.integer(match[1, 2])
  
  if (is.na(total_momentum_sq)) {
    return (NA)
  }
  
  relative_momenta_markus <- as.integer(match[1, 3:5])
  
  total_momentum_vec <- total_momentum_ref(total_momentum_sq)
  relative_momenta_martin <- round(total_momentum_vec / 2 - relative_momenta_markus)
  
  momentum_to_string(relative_momenta_martin)
}

parse_markus_gevp_indices('p: 1, q: (1.0, 1.0, 0.5), g: \\gamma_{5}, \\gamma_{5}')
parse_markus_gevp_indices('p: 1, g: \\gamma_{5}')
```

We read the operators that Markus has.

```{r}
.func <- function (param, value) {
  operator_indices_path <- sprintf('%s/reference/rho_p%d_%s_operator-indices.tsv', workdir, value$total_momentum_sq, param$irrep)  
  if (!file.exists(operator_indices_path)) {
    return (NA)
  }
  operator_indices <- read.table(operator_indices_path, sep = '\t', header = TRUE)
  
  filtered <- operator_indices %>%
    filter(p_x == value$total_momentum_vec[1],
           p_y == value$total_momentum_vec[2],
           p_z == value$total_momentum_vec[3],
           alpha == 1) %>%
    select(id, alpha)
  operator_id <- filtered$id
  
  gevp_indices_path <- sprintf('%s/reference/rho_p%d_%s_gevp-indices.tsv', workdir, value$total_momentum_sq, param$irrep)
  
  if (!file.exists(gevp_indices_path)) {
    return (NA)
  }
  
  gevp_indices <- read.table(gevp_indices_path, sep = '\t', header = TRUE, stringsAsFactors = FALSE)
  
  target_gevp_indices_converted <- gevp_indices %>%
    mutate(relative_momenta = sapply(element, parse_markus_gevp_indices)) %>%
    filter(!is.na(relative_momenta)) %>%
    select(id, relative_momenta)
  
  list(target_gevp_indices = target_gevp_indices_converted,
       target_operator_id = filtered)
}

target_avail <- pv_call(.func, irreps, total_momentum)
```

# Matching up available and actual

Markus and I have chosen different representatives for the relative momenta from each orbit. This means that at first glance there are many GEVP elements just missing in the other data. One must use a list of relative momenta from the orbits in order to match this up. Using Mathematica we can create a mapping from relative momentum labels to their respective orbit representative.

```{r}
path <- sprintf('%s/momenta_orbits.js', workdir)
momentum_orbits <- jsonlite::read_json(path)
```

```{r}
.func <- function (param, value) {
  df <- tibble(
    target_gevp_id = value$target_gevp_indices$id,
    target_relative_momenta = as.character(momentum_orbits[[param$total_momentum_str]][value$target_gevp_indices$relative_momenta])) %>%
    filter(target_relative_momenta %in% value$actual_avail)
  
  if (nrow(df) == 0) {
    return (NA)
  }
  
  i <- 1:nrow(df)
  
  grid <- as_tibble(expand.grid(i = i, j = i))
  attr(grid, 'out.attrs') <- NULL
  grid$target_source_id <- df$target_gevp_id[grid$i]
  grid$target_sink_id <- df$target_gevp_id[grid$j]
  grid$source_relative_momenta <- df$target_relative_momenta[grid$i]
  grid$sink_relative_momenta <- df$target_relative_momenta[grid$j]
  grid$i <- NULL
  grid$j <- NULL
  
  stopifnot(all(!is.na(grid$target_source_id)))
  stopifnot(all(!is.na(grid$target_sink_id)))
  
  list(matched_up_grid = grid)
}

matched_up <- pv_call(.func, actual_avail, target_avail)
```

```{r}
load_target_config <- function (path, config_number) {
  target <- read.table(path, header = TRUE)
  
  target_single <- dplyr::filter(target, cnfg == config_number)
  target_single$value
}

.func <- function (param, value) {
  stopifnot(nrow(value$target_operator_id) == 1)
  
  grid <- value$matched_up_grid
  
  grid$filename_target <- sprintf(
    '%s/reference/rho_p%d_%s_op%d_gevp%d.%d.tsv',
    workdir,
    value$total_momentum_sq,
    param$irrep,
    value$target_operator_id$id,
    grid$target_source_id,
    grid$target_sink_id)
  
  target_loaded <- lapply(grid$filename_target, load_target_config, config_number = param$config_number)
  grid$target <- target_loaded
  
  filename_actual <- value$path
  resolved <- jsonlite::read_json(filename_actual)
  load_actual_config <- function (q_source, q_sink) {
    irrep_col <- if (param$irrep %in% c('T1u', 'E')) '2' else '1'
    unlist(resolved[[param$total_momentum_str]][[param$irrep]][[irrep_col]][['1']][[q_source]][[q_sink]])
  }
  actual_loaded <- mapply(load_actual_config, grid$source_relative_momenta, grid$sink_relative_momenta, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  grid$actual <- actual_loaded
  
  grid$time <- lapply(1:nrow(grid), function (i) 0:(length(grid$actual[[1]])-1))
                        
  list(filename_actual = filename_actual,
       grid = grid)
}

loaded <- pv_call(.func, matched_up, total_momentum, target_avail, irreps)
```

```{r}
.func <- function (param, value) {
  long <- tidyr::unnest(value$grid)
  long2 <- tidyr::gather(long, kind, correlator, target, actual)
  
  list(loaded_long = long2)
}

loaded_long <- pv_call(.func, loaded)
```


```{r}
.func <- function (param, value) {
  p <- ggplot(value$loaded_long, aes(x = time, y = abs(correlator), color = kind)) +
    geom_point(position = position_dodge(width = 0.3)) +
    scale_y_log10() +
    facet_grid(source_relative_momenta ~ sink_relative_momenta) +
    labs(title = "Comparison between Martin's and Markus's projection code",
         subtitle = sprintf('P = %s, irrep = %s', param$total_momentum_str, param$irrep),
         x = 't',
         y = expression(abs(C(t))),
         color = 'Data')
  
  path <- sprintf('%s/comparison', workdir)
  if (!dir.exists(path)) {
    dir.create(path)
  }
  ggsave(sprintf('%s/comparison-%s-%s.pdf', path, param$total_momentum_str, param$irrep), p, width = 10, height = 10)
  
  print(p)
  
  list()
}

pv_call(.func, loaded_long)
```

